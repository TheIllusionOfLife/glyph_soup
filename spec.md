# Glyph Soup — 実装仕様書

> **Document Role:** Implementation Specification (authoritative)
> **Based on:**
> - [`research_plan.md`](research_plan.md) — 初期研究計画（構想・RQ・実験シナリオの原案）
> - [`review_unified.md`](review_unified.md) — 統一レビュー（計画の問題点と推奨アクション）
> - [`生命の起源とアセンブリ理論レポート.md`](生命の起源とアセンブリ理論レポート.md) — アセンブリ理論の参照資料
> - 研究者インタビュー — パラメータ選択・スコープ・設計判断の確定
>
> **This is the document to follow for implementation.** The research plan and review are retained for context and audit trail.

---

## 1. システム概要

| 項目 | 決定事項 |
|------|---------|
| リポジトリ構成 | モノレポ（`glyph_soup/`に全コード） |
| 言語 | Python先行 → ボトルネック判明後にRustで最適化 |
| 実装基盤 | Rust/C拡張も視野に入れるが、まずPure Pythonで動作確認 |
| 出力形式 | CSV出力 + Jupyter Notebookで分析・可視化 |
| ゲームエンジン連携 | Python完成後に最適なエンジン（Unity/Unreal/Godot等）を選定 |
| スコープ | 全実験（A・B・C）+ ゲームエンジンによる視覚化 |

---

## 2. データ構造

### 2.1 分子の内部表現：二分木

分子は二分木（Binary Tree）で表現する。文字列表現は表示・ハッシュ比較用。

```
分子 ((A,B),(C,D)) の木表現:

       *
      / \
     *   *
    / \ / \
   A  B C  D
```

### 2.2 結合の対称性：要検討パラメータ

- **(A,(B,C))** と **((B,C),A)** を同一とみなすか否かは実験パラメータとして扱う
- 両条件（対称/非対称）を実装し、ダイナミクスの差異を比較する
- 対称モードでは正規形（canonical form）への変換が必要

---

## 3. シミュレーションパラメータ

| パラメータ | 値 |
|-----------|-----|
| アルファベットサイズ | 4種（A, B, C, D） |
| タンク内総原子数 | ~1,000 |
| 1ランのステップ数 | 100,000 |
| seed数（実験Aの統計計画） | 100回 |

---

## 4. 指標体系（3層設計）

レビューで指摘されたC1（指標の乖離）を解決するため、3層の指標を定義する。

### 4.1 個別指標（分子種レベル）

$$S_i = A_i \times N_i$$

各分子種$i$のアセンブリ指数$A_i$とコピー数$N_i$の積。ヒートマップ（MA-CN散布図）のプロット用。

### 4.2 系全体指標

$$A_{total} = \sum_{i} (A_i \times N_i)$$

系全体のアセンブリ状態を定量化。相転移検出の主要指標。

### 4.3 分布形状指標

MA-CN散布図のクラスタ形成パターンを分析し、以下を区別する：
- **ランダムな複雑さ**: 高$A$・低$N$（偶然の産物）
- **組織化された複雑さ**: 中〜高$A$・極めて高$N$（選択と複製の結果）

---

## 5. MA計算アルゴリズム

### 5.1 方針

**近似解（貪欲法＋キャッシュ）** を採用する。

- 貪欲法で最大の再利用可能サブ構造を優先的にマッチする
- 計算済みMAをキャッシュし、同一構造の再計算を回避
- 厳密解との乖離率は初期ベンチマーク時に確認する

### 5.2 ベンチマーク要件

プロジェクト最初期にプロトタイプ実装し、以下を計測する：
- 分子長（ノード数） vs 計算時間
- 近似解 vs 厳密解（小規模サンプル）の乖離率
- タンク全分子のMA一括計算のスループット

---

## 6. 反応ルール

### 6.1 Bonding（結合）

```
X + Y → Join(X, Y)    確率: P_bond
```

- 結合位置：二分木のルートに新ノードを作り、X・Yを左右の子とする
- `P_bond` は定数（初期値はパラメータ探索で決定）

### 6.2 Breaking（分解）

```
Join(X, Y) → X + Y    確率: P_break(molecule)
```

- 切断位置：二分木の内部ノードをランダムに選択し、そこで切断
- 分解確率関数 `P_break` は**実験パラメータ**として以下を比較する：
  - **線形**: $P_{break} \propto n$（分子長$n$に線形比例）
  - **指数**: $P_{break} \propto \exp(\alpha n)$
  - **ノード数比例**: $P_{break} \propto |\text{internal nodes}|$

### 6.3 Catalysis（触媒）[Phase 2: 実験B以降]

```
X + Y + C → Join(X, Y) + C    確率: P_bond × boost(C, X, Y)
```

触媒マッチングは**2方式を比較**する：

#### 方式1: 構造決定論的
- **文字列部分一致**: 触媒のフラット表現が基質のフラット表現に含まれるか
- **木構造部分一致**: 触媒の部分木が基質の部分木と同型か
- 両方実装し、「触媒記述の解像度」がダイナミクスに与える影響を比較

#### 方式2: ランダムテーブル
- seedごとにランダムな触媒マップを生成
- 設計者バイアスを排除し、創発の主張を堅固にする

---

## 7. 閾値の再校正（C2対処）

参照理論の $A > 15$ は実分子測定の経験的境界であり、文字列人工化学にそのまま移植しない。

### 校正手順

1. 実験A（ランダム条件）を100 seedで実行
2. 各seedにおける$A_{total}$と最大MAの分布を取得
3. 分布の99パーセンタイルを「ランダム上限」とする
4. この上限を超える状態を「非ランダム領域」と定義
5. 以降の実験B・Cの判定基準として使用

---

## 8. アセンブリ転移の操作的定義

**$A_{total}$ の時系列における急激な勾配変化**をもって「転移」と判定する。

具体的には：
- $A_{total}$の移動平均の二階差分（加速度）が閾値を超えた時点
- 閾値は実験Aのランダム条件での最大勾配変化から設定（上記の校正手順と連動）

---

## 9. 統計計画

| 項目 | 値 |
|------|-----|
| seed数 | 100（各実験条件） |
| seed管理 | 固定（0-99）で再現性を保証 |
| 比較検定 | KS検定（$A_{total}$ 分布の条件間比較） |
| 効果量 | Cohen's d |
| 報告 | 信頼区間（95%）付きで報告 |

---

## 10. 実験設計

### 実験A: 帰無仮説検証（ベースライン）

- **条件**: ランダムなBonding/Breaking。触媒なし。
- **目的**: ランダム条件でのMA分布上限を確立し、独自閾値を校正する。
- **出力**: $A_{total}$時系列、MA分布、MA-CN散布図

### 実験B: 自己触媒の効果

- **条件**: 実験Aに触媒メカニズムを追加
- **サブ条件**:
  - B-1: 構造決定論的触媒（文字列部分一致）
  - B-2: 構造決定論的触媒（木構造部分一致）
  - B-3: ランダムテーブル触媒
- **目的**: 触媒導入によるMA分布・$A_{total}$の変化を定量化。触媒記述方式による差異を分析。

### 実験C: 非限定的進化（アブレーション設計）

4因子を以下の順で1つずつ追加する：

| サブ実験 | 追加因子 | ベース |
|---------|---------|--------|
| C-1 | 資源競合（総原子数上限） | 実験Bの最良条件 |
| C-2 | 触媒耐性（触媒を持つ分子の分解率低下） | C-1 |
| C-3 | 突然変異（まれに葉ノードの文字が変化） | C-2 |
| C-4 | エネルギー効率（複雑な分子の維持コスト） | C-3 |

各サブ実験で100 seed × 100Kステップ。前段の結果と比較。

---

## 11. プロジェクト構成（モノレポ）

```
glyph_soup/
├── research_plan.md          # 研究計画書（原本）
├── review_unified.md         # 統一レビュー
├── spec.md                   # 本仕様書
├── src/
│   ├── glyph_soup/
│   │   ├── __init__.py
│   │   ├── molecule.py       # 二分木データ構造
│   │   ├── assembly.py       # MA計算アルゴリズム
│   │   ├── reactor.py        # Reactor（タンク管理）
│   │   ├── chemist.py        # Chemist（反応ルール）
│   │   ├── observer.py       # Observer（指標計算・CSV出力）
│   │   └── config.py         # パラメータ管理
│   └── rust_core/            # [将来] Rust高速化モジュール
├── experiments/
│   ├── exp_a/                # 実験A: ベースライン
│   ├── exp_b/                # 実験B: 触媒
│   └── exp_c/                # 実験C: アブレーション
├── notebooks/
│   ├── analysis_a.ipynb      # 実験A分析
│   ├── analysis_b.ipynb      # 実験B分析
│   └── analysis_c.ipynb      # 実験C分析
├── game/                     # [将来] ゲームエンジンプロジェクト
├── tests/
├── pyproject.toml
└── README.md
```

---

## 12. 開発フェーズ

### Phase 1: コア実装 + ベンチマーク
- 二分木データ構造（`molecule.py`）
- MA計算アルゴリズム（`assembly.py`）+ ベンチマーク
- 対称性の両モード実装

### Phase 2: シミュレーションエンジン
- Reactor, Chemist, Observer の実装
- パラメータ管理（`config.py`）
- CSV出力

### Phase 3: 実験A + 閾値校正
- 100 seed × 100Kステップのバッチ実行
- 分析Notebook作成
- Glyph Soup固有の閾値確立

### Phase 4: 実験B（触媒）
- 触媒メカニズム3方式の実装
- 比較分析

### Phase 5: 実験C（アブレーション）
- 4因子の段階的追加（資源競合→触媒耐性→突然変異→エネルギー効率）
- 各段階での比較分析

### Phase 6: ゲームエンジン視覚化
- エンジン選定（連携の容易さで判断）
- Python ↔ エンジン間通信の実装
- リアルタイム可視化

### Phase 7: [Optional] Rust最適化
- Phase 3以降でボトルネックが判明した場合に実行
- MA計算 or Reactor のホットパスをRustで再実装
